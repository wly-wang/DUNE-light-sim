#!/bin/bash
:<<'EOF'

To use this jobscript to process 5 files from the dataset fardet-hd__fd_mc_2023a_reco2__full-reconstructed__v09_81_00d02__standard_reco2_dune10kt_nu_1x2x6__prodgenie_nu_dune10kt_1x2x6__out1__validation
data and put the output in the $USER namespace (MetaCat) and saves the output in /scratch
Use this command to create the workflow:

justin simple-workflow \
--mql \
"files from dune:all where core.file_type=detector and core.run_type=hd-protodune and core.data_tier=raw limit 10" \
--jobscript submit_local_fcl.jobscript --rss-mb 4000 --max-distance 30 --scope usertests \
--output-pattern "*_reco_*.root:$FNALURL/$USERF" \
--env INPUT_TAR_DIR_LOCAL="$INPUT_TAR_DIR_LOCAL" --env NUM_EVENTS=1

The following optional environment variables can be set when creating the
workflow/stage: FCL_FILE, NUM_EVENTS, DUNE_VERSION, DUNE_QUALIFIER 

EOF

# fcl file and DUNE software version/qualifier to be used
FCL_FILE=${FCL_FILE:-$INPUT_TAR_DIR_LOCAL/to_grid/dune10kt_v6_refactored_1x2x6_light_sim.fcl}
DUNE_VERSION=${DUNE_VERSION:-v10_03_01d02}
DUNE_QUALIFIER=${DUNE_QUALIFIER:-e26:prof}

# number of events to process from the input file
if [ "$NUM_EVENTS" != "" ] ; then
 events_option="-n $NUM_EVENTS"
fi

# First get an unprocessed file from this stage
did_pfn_rse=`$JUSTIN_PATH/justin-get-file`

if [ "$did_pfn_rse" = "" ] ; then
  echo "Nothing to process - exit jobscript"
  exit 0
fi

# Keep a record of all input DIDs, for pdjson2meta file -> DID mapping
echo "$did_pfn_rse" | cut -f1 -d' ' >>all-input-dids.txt

# pfn is also needed when creating justin-processed-pfns.txt
pfn=`echo $did_pfn_rse | cut -f2 -d' '`
echo "Input PFN = $pfn"

# Setup DUNE environment
source /cvmfs/dune.opensciencegrid.org/products/dune/setup_dune.sh
setup dunesw "$DUNE_VERSION" -q "$DUNE_QUALIFIER"

# Construct outFile from input $pfn 
now=$(date -d '-20 day' -u +"%Y-%m-%dT_%H%M%SZ")
Ffname=`echo $pfn | awk -F/ '{print $NF}'`
fname=`echo $Ffname | awk -F. '{print $1}'`
outFile=${fname}_reco_${now}.root

campaign="justIN.w${JUSTIN_WORKFLOW_ID}s${JUSTIN_STAGE_ID}"

# Here is where the LArSoft command is called
for input_file in myLightSourceSteering_*.txt; do
  # Check if no files left
  [ -e "$input_file" ] || break

  echo "Processing $input_file..."
  
  # Rename to standard input name that's expected by FCL
  cp "$input_file" myLightSourceSteering.txt

  # Run lar with current renamed input
  (
    export LD_PRELOAD=${XROOTD_LIB}/libXrdPosixPreload.so
    echo "$LD_PRELOAD"

    lar -c $FCL_FILE $events_option -o "${fname}_reco_${now}_${input_file}.root" "$pfn" \
      > "${fname}_reco_${now}_${input_file}.log" 2>&1
  )

  larExit=$?
  echo "lar exit code $larExit"

  if [ $larExit -eq 0 ]; then
    echo "$pfn" >> justin-processed-pfns.txt
  else
    # Oh :(
    jobscriptExit=1
    echo "!!! Failed to process $input_file !!!"
  fi

done


# echo '=== Start last 100 lines of lar log file ==='
# tail -100 ${fname}_reco_${now}.log
# echo '=== End last 100 lines of lar log file ==='

# # Subshell exits with exit code of last command
# larExit=$?
# echo "lar exit code $larExit"

# if [ $larExit -eq 0 ] ; then
#   # Success !
#   echo "$pfn" > justin-processed-pfns.txt
#   jobscriptExit=0
# else
#   # Oh :(
#   jobscriptExit=1
# fi

# Create compressed tar file with all log files 
tar zcf `echo "$JUSTIN_JOBSUB_ID.logs.tgz" | sed 's/@/_/g'` *.log
exit $jobscriptExit
